var g_data = {"name":"/home/noname/Documents/project_tiny/Floating_point/Verision1/03_verif/TopModule/tb_FPU_unit.sv","src":"`timescale 1ns/1ps\n\nmodule tb_FPU_unit ();\n\nparameter ALU_OP = 1;\nparameter SIZE_ADDR = 11;\nlogic i_clk, i_rst_n;\nlogic        i_add_sub;\nlogic [31:0] i_32_a;\nlogic [31:0] i_32_b;\nlogic [31:0] o_32_s;\nlogic        o_ov_flow;\nlogic        o_un_flow;\nlogic [SIZE_ADDR-1:0]   w_i_addr;\nlogic [31:0]            w_o_data_rom_a;\nlogic [31:0]            w_o_data_rom_b;\n\nint test_count = 0;\nint test_pass  = 0;\n\nFPU_unit #(\n    .NUM_OP     (ALU_OP)\n) DUT (\n    .i_add_sub       (i_add_sub),\n    .i_32_a          (i_32_a),\n    .i_32_b          (i_32_b),\n    .o_32_s          (o_32_s),\n    .o_ov_flag       (o_ov_flow),\n    .o_un_flag       (o_un_flow) \n);\nsingle_port_rom #(\n    .FILE_DATA      (\"/home/noname/Documents/project_tiny/Floating_point/Verision1/03_verif/TopModule/FPU_list_A.txt\"),\n    .DATA_WIDTH     (32),\n    .ADDR_WIDTH     (SIZE_ADDR)\n) ROM_UNIT_A (\n	.addr           (w_i_addr),\n    .rst_n          (i_rst_n),\n	.clk            (i_clk), \n	.q              (w_o_data_rom_a)\n);\nsingle_port_rom #(\n    .FILE_DATA      (\"/home/noname/Documents/project_tiny/Floating_point/Verision1/03_verif/TopModule/FPU_list_B.txt\"),\n    .DATA_WIDTH     (32),\n    .ADDR_WIDTH     (SIZE_ADDR)\n) ROM_UNIT_B (\n	.addr           (w_i_addr),\n    .rst_n          (i_rst_n),\n	.clk            (i_clk), \n	.q              (w_o_data_rom_b)\n);\n\ninitial begin\n    $dumpfile(\"tb_FPU_unit.vcd\");\n    $dumpvars(0, tb_FPU_unit);\nend\ninitial begin\n    i_clk = 1'b0;\n    forever begin\n        #10 i_clk = ~i_clk;\n    end\nend\nfunction automatic shortreal float_to_real(input logic [31:0] f);\n    int temp;                        // 32-bit integer container\n    temp = int'(f);                  // ép logic -> int (2-state)\n    return $bitstoshortreal(temp);   // chuyển bit -> shortreal\nendfunction\nfunction automatic logic [31:0] real_to_float(input shortreal f);\n    real_to_float = $shortrealtobits(f);\nendfunction\nfunction automatic shortreal check_functional(\n    input logic             f_i_add_sub ,\n    input logic [31:0]      f_i_32_a    ,\n    input logic [31:0]      f_i_32_b     \n);\n    shortreal f_sr_32_a, f_sr_32_b, f_sr_32_e;\n    begin\n        f_sr_32_a = float_to_real(f_i_32_a);\n        f_sr_32_b = float_to_real(f_i_32_b);\n        f_sr_32_e = (f_i_add_sub) ? f_sr_32_a - f_sr_32_b : f_sr_32_a + f_sr_32_b;\n\n        return f_sr_32_e;\n    end\nendfunction\n// function automatic shortreal cal_rounding_error(\n//     input shortreal f_sr_32_s   ,\n//     input shortreal f_sr_32_e   \n// );\n//     begin\n//         if (f_sr_32_e == 0.0)\n//             cal_rounding_error = (f_sr_32_s == 0.0) ? 0.0 : 100.0;\n//         else\n//             cal_rounding_error = ((f_sr_32_s - f_sr_32_e) / f_sr_32_e) * 100.0;\n//     end\n// endfunction\nfunction automatic shortreal abs_shortreal(input shortreal val);\n    if (val < 0.0)\n        abs_shortreal = -val;\n    else\n        abs_shortreal = val;\nendfunction\n\nfunction automatic shortreal cal_rounding_error(\n    input shortreal f_sr_32_s,\n    input shortreal f_sr_32_e\n);\n    int s_bits, e_bits;\n    bit s_is_nan, e_is_nan, s_is_inf, e_is_inf;\n    shortreal diff;\n\n    begin\n        // Chuyển từ shortreal → bit pattern (int 32-bit)\n        s_bits = $shortrealtobits(f_sr_32_s);\n        e_bits = $shortrealtobits(f_sr_32_e);\n\n        // Tách các phần của IEEE 754 single-precision\n        // [31]: sign, [30:23]: exponent, [22:0]: fraction\n        s_is_nan = ((s_bits[30:23] == 8'hFF) && (s_bits[22:0] != 0));\n        e_is_nan = ((e_bits[30:23] == 8'hFF) && (e_bits[22:0] != 0));\n        s_is_inf = ((s_bits[30:23] == 8'hFF) && (s_bits[22:0] == 0));\n        e_is_inf = ((e_bits[30:23] == 8'hFF) && (e_bits[22:0] == 0));\n\n        // Nếu có NaN hoặc Inf thì bỏ qua\n        if (s_is_nan || e_is_nan || s_is_inf || e_is_inf) begin\n            cal_rounding_error = 0.0;\n        end\n        else if (f_sr_32_e == 0.0) begin\n            cal_rounding_error = (f_sr_32_s == 0.0) ? 0.0 : 100.0;\n        end\n        else begin\n            diff = f_sr_32_s - f_sr_32_e;\n            cal_rounding_error = (abs_shortreal(diff) / abs_shortreal(f_sr_32_e)) * 100.0;\n        end\n    end\nendfunction\n\nfunction shortreal error_avariable ();\n    begin\n        return ((2.0 ** (-23.0)) / 1.0) * 100.0;\n    end\nendfunction\n\ntask automatic Display_result(\n    string                      t_type      ,\n    input logic                 t_i_add_sub ,\n    input logic [31:0]          t_i_32_a    ,\n    input logic [31:0]          t_i_32_b    ,\n    input logic [31:0]          t_o_32_s    ,\n    input logic                 t_o_ov_flow ,\n    input logic                 t_o_un_flow  \n);\n    shortreal t_sr_32_a, t_sr_32_b, t_sr_32_s, t_sr_32_e, t_sr_rounding_error;\n    shortreal t_error;\n    t_error = error_avariable();\n    t_sr_32_a = float_to_real(t_i_32_a);\n    t_sr_32_b = float_to_real(t_i_32_b);\n    t_sr_32_s = float_to_real(t_o_32_s);\n    t_sr_32_e = check_functional(t_i_add_sub, t_i_32_a, t_i_32_b);\n    t_sr_rounding_error = cal_rounding_error(t_sr_32_s, t_sr_32_e);\n    begin\n        $display(\"[%s][%s]i_32_a=%h (%.24f) %s i_32_b=%h (%.24f) \\t| o_32_s=%h (%.24f) \\t| o_ov_flow=%b, o_un_flow=%b\",\n                    t_type, (t_i_add_sub == 1'b1) ? \"SUB\" : \"ADD\", \n                    t_i_32_a, t_sr_32_a, (t_i_add_sub == 1'b1) ? \"-\" : \"+\", t_i_32_b, t_sr_32_b, t_o_32_s, t_sr_32_s,\n                    t_o_ov_flow, t_o_un_flow);\n        $display(\"=> %s: expect=%.24f (%h), dut=%.24f (%h), rounding_error=%.8f %% (exp_error = %.8f %%)\", \n                    (t_sr_rounding_error <= t_error) ? \"PASS\" : \"FAIL\", \n                    t_sr_32_e, real_to_float(t_sr_32_e), t_sr_32_s, real_to_float(t_sr_32_e), t_sr_rounding_error, t_error);\n        test_count++;\n        if (t_sr_rounding_error <= t_error) test_pass++;\n    end\nendtask\ntask automatic TestCase_Display_result(\n    string              t_type,\n    string              t_testcase,\n    input logic [31:0]  t_i_fpu_a,\n    input logic [31:0]  t_i_fpu_b\n);\n    begin\n        $display(\"==========[ %s ]==========\", t_testcase);\n        @(posedge i_clk);\n        #1;\n        i_add_sub   = 1'b0;\n        i_32_a      = t_i_fpu_a;\n        i_32_b      = t_i_fpu_b;\n        @(negedge i_clk);\n        #1;\n        Display_result(t_type, i_add_sub, i_32_a, i_32_b, o_32_s, o_ov_flow, o_un_flow);\n        @(posedge i_clk);\n        #1;\n        i_add_sub   = 1'b0;\n        i_32_a      = t_i_fpu_b;\n        i_32_b      = t_i_fpu_a;\n        @(negedge i_clk);\n        #1;\n        Display_result(t_type, i_add_sub, i_32_a, i_32_b, o_32_s, o_ov_flow, o_un_flow);\n        @(posedge i_clk);\n        #1;\n        i_add_sub   = 1'b1;\n        i_32_a      = t_i_fpu_a;\n        i_32_b      = t_i_fpu_b;\n        @(negedge i_clk);\n        #1;\n        Display_result(t_type, i_add_sub, i_32_a, i_32_b, o_32_s, o_ov_flow, o_un_flow);\n        @(posedge i_clk);\n        #1;\n        i_add_sub   = 1'b1;\n        i_32_a      = t_i_fpu_b;\n        i_32_b      = t_i_fpu_a;\n        @(negedge i_clk);\n        #1;\n        Display_result(t_type, i_add_sub, i_32_a, i_32_b, o_32_s, o_ov_flow, o_un_flow);\n    end\nendtask //automatic\n\ninitial begin\n    i_rst_n = 0;\n    i_add_sub       = 1'b0;\n    i_32_a          = 32'h0;\n    i_32_b          = 32'h0;\n    w_i_addr        = '0;\n    #100;\n    i_rst_n = 1;\n    #100;\n    TestCase_Display_result(\"ZERO\", \"(0.0 & 0.0)\", 32'h00000000, 32'h00000000);\n    TestCase_Display_result(\"ZERO\", \"(0.0 & -0.0)\", 32'h00000000, 32'h80000000);\n    TestCase_Display_result(\"ZERO\", \"(0.0 & -0.0)\", 32'h4016A197, 32'h4016A197);\n    TestCase_Display_result(\"ZERO\", \"(0.0 & -0.0)\", 32'h40AED834, 32'h40AED834);\n    TestCase_Display_result(\"INF\", \"(inf & inf)\", 32'h7f800000, 32'h7f800000);\n    TestCase_Display_result(\"INF\", \"(-inf & -inf)\", 32'hff800000, 32'hff800000);\n    TestCase_Display_result(\"INF\", \"(inf & -inf)\", 32'hff800000, 32'h7f800000);\n    TestCase_Display_result(\"INF\", \"(inf & 0)\", 32'h7f800000, 32'h00000000);\n    TestCase_Display_result(\"INF\", \"(-inf & 0)\", 32'hff800000, 32'h00000000);\n    TestCase_Display_result(\"INF\", \"(inf & Number)\", 32'h7f800000, 32'h40533333);\n    TestCase_Display_result(\"INF\", \"(-inf & Number)\", 32'hff800000, 32'h40533333);\n    TestCase_Display_result(\"INF\", \"(inf & -Number)\", 32'h7f800000, 32'hc00ccccd);\n    TestCase_Display_result(\"INF\", \"(-inf & -Number)\", 32'hff800000, 32'hc00ccccd);\n    TestCase_Display_result(\"NaN\", \"(NaN & -Number)\", 32'h7f800001, 32'hc00ccccd);\n    TestCase_Display_result(\"NaN\", \"(-NaN & -Number)\", 32'hff800001, 32'hc00ccccd);\n    TestCase_Display_result(\"NaN\", \"(NaN &  Number)\", 32'hff800001, 32'h40533333);\n    TestCase_Display_result(\"NaN\", \"(-NaN &  Number)\", 32'h7f800001, 32'h40533333);\n    TestCase_Display_result(\"APPRO\", \"APPR INF\", 32'h7f21616f, 32'h007fffff);\n    TestCase_Display_result(\"APPRO\", \"APPR INF\", 32'h7f7fffff, 32'h00ffffff);\n    TestCase_Display_result(\"APPRO\", \"APPR INF\", 32'h7f7fffff, 32'h007fffff);\n    TestCase_Display_result(\"APPRO\", \"APPR ZERO\", 32'h00ffffff, 32'h007fffff);\n    TestCase_Display_result(\"APPRO\", \"APPR ZERO\", 32'h00ffffff, 32'h00ffffff);\n    TestCase_Display_result(\"SIGN\", \"(-A + B)\", 32'hc00ccccd, 32'h40533333);\n    TestCase_Display_result(\"SIGN\", \"TEST SIGN\", 32'hc00ccccd, 32'hc0533333);\n    TestCase_Display_result(\"SIGN\", \"TEST SIGN\", 32'hc00ccccd, 32'hc1b1999a);\n    repeat(2**SIZE_ADDR) begin\n    // repeat(10) begin\n        TestCase_Display_result(\"Random\", \"Read data from ROM\", w_o_data_rom_a, w_o_data_rom_b);\n        @(posedge i_clk);\n        #1;\n        w_i_addr = w_i_addr + 1;\n    end\n    \n    // --- Summary ---\n    #100;\n        $display(\"\\n==================================\");\n        $display(\"========== TEST SUMMARY ==========\");\n        $display(\"Total test cases: %6d\", test_count);\n        $display(\"Passed          : %6d\", test_pass);\n        $display(\"Failed          : %6d\", test_count - test_pass);\n        $display(\"Pass rate       : %0.2f%%\", (test_pass * 100.0) / test_count);\n        $display(\"==================================\\n\");\n    #100;\n    $finish;\nend\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);